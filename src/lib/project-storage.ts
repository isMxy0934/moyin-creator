// Copyright (c) 2025 hotflow2024
// Licensed under AGPL-3.0-or-later. See LICENSE for details.
// Commercial licensing available. See COMMERCIAL_LICENSE.md.
/**
 * Project-Scoped Storage Adapters for Zustand
 * 
 * Routes store data to per-project files under _p/{projectId}/
 * and shared data to _shared/
 */

import type { StateStorage } from 'zustand/middleware';
import { fileStorage } from './indexed-db-storage';
import { useProjectStore } from '@/stores/project-store';
import { useAppSettingsStore } from '@/stores/app-settings-store';

// ==================== Helpers ====================

/**
 * Get current activeProjectId from project-store.
 * MUST be called synchronously (before any await) to avoid race conditions.
 */
function getActiveProjectId(): string | null {
  try {
    return useProjectStore.getState().activeProjectId;
  } catch {
    return null;
  }
}

/**
 * Get resource sharing settings from app-settings-store.
 */
function getResourceSharing(): { shareCharacters: boolean; shareScenes: boolean; shareMedia: boolean } {
  try {
    return useAppSettingsStore.getState().resourceSharing;
  } catch {
    // Default to isolation when settings are unavailable during early bootstrap.
    return { shareCharacters: false, shareScenes: false, shareMedia: false };
  }
}

/**
 * Get all project IDs from project-store.
 */
function getAllProjectIds(): string[] {
  try {
    return useProjectStore.getState().projects.map(p => p.id);
  } catch {
    return [];
  }
}

// ==================== Project-Scoped Storage ====================

/**
 * Creates a StateStorage that routes data to _p/{activeProjectId}/{storeName}.json
 * Used for stores that are entirely project-scoped (script, director, timeline).
 * 
 * On getItem: reads from _p/{pid}/{storeName}, falls back to legacy key if not migrated
 * On setItem: writes to _p/{pid}/{storeName}
 */
export function createProjectScopedStorage(storeName: string): StateStorage {
  return {
    getItem: async (name: string): Promise<string | null> => {
      // 等待 project-store 完成 rehydration，确保拿到正确的 activeProjectId
      // 否则启动时可能读到默认值 "default-project"，导致读错文件
      if (!useProjectStore.persist.hasHydrated()) {
        await new Promise<void>((resolve) => {
          const unsub = useProjectStore.persist.onFinishHydration(() => {
            unsub();
            resolve();
          });
        });
      }

      const pid = getActiveProjectId();
      
      if (!pid) {
        console.warn(`[ProjectStorage] No activeProjectId, falling back to legacy key: ${name}`);
        return fileStorage.getItem(name);
      }

      const projectKey = `_p/${pid}/${storeName}`;
      
      // Try project-scoped path first
      const projectData = await fileStorage.getItem(projectKey);
      if (projectData) {
        console.log(`[ProjectStorage] Loaded ${storeName} for project ${pid.substring(0, 8)}`);
        return projectData;
      }

      // Fall back to legacy monolithic file (pre-migration)
      console.log(`[ProjectStorage] Project file not found for ${storeName}, trying legacy key: ${name}`);
      return fileStorage.getItem(name);
    },

    setItem: async (name: string, value: string): Promise<void> => {
      // Extract the intended project ID from the data being persisted.
      // This ensures data is always written to the correct per-project file,
      // even if getActiveProjectId() returns a different value due to race conditions
      // (e.g., during app startup when project-store hasn't rehydrated yet,
      //  or during project duplication when createProject changes the active ID).
      let dataProjectId: string | null = null;
      try {
        const parsed = JSON.parse(value);
        const state = parsed?.state ?? parsed;
        if (state && typeof state === 'object' && typeof state.activeProjectId === 'string') {
          dataProjectId = state.activeProjectId;
        }
      } catch {
        // If we can't parse the value, fall back to getActiveProjectId()
      }

      const pid = dataProjectId || getActiveProjectId();
      
      if (!pid) {
        // No project active, save to legacy location
        await fileStorage.setItem(name, value);
        return;
      }

      // Log a warning if there's a mismatch (indicates a race condition was avoided)
      const routerPid = getActiveProjectId();
      if (dataProjectId && routerPid && dataProjectId !== routerPid) {
        console.warn(
          `[ProjectStorage] Routing mismatch for ${storeName}: data.pid=${dataProjectId.substring(0, 8)}, ` +
          `router.pid=${routerPid.substring(0, 8)}. Using data.pid to prevent cross-project overwrite.`
        );
      }

      const projectKey = `_p/${pid}/${storeName}`;
      console.log(`[ProjectStorage] Saving ${storeName} for project ${pid.substring(0, 8)} (${Math.round(value.length / 1024)}KB)`);
      await fileStorage.setItem(projectKey, value);
    },

    removeItem: async (name: string): Promise<void> => {
      const pid = getActiveProjectId();
      if (!pid) {
        await fileStorage.removeItem(name);
        return;
      }
      const projectKey = `_p/${pid}/${storeName}`;
      await fileStorage.removeItem(projectKey);
    },
  };
}

// ==================== Split Storage ====================

/**
 * Split/merge function types for flat-array stores.
 * splitFn: takes the persisted state object and splits it into project-specific and shared parts
 * mergeFn: merges project-specific and shared data back into a single state object
 */
export type SplitFn<T = unknown> = (state: T, projectId: string) => { projectData: T; sharedData: T };
export type MergeFn<T = unknown> = (projectData: T | null, sharedData: T | null) => T;

/**
 * Creates a StateStorage that splits flat-array data between:
 * - _p/{activeProjectId}/{storeName}.json (project-specific items)
 * - _shared/{storeName}.json (shared/global items)
 * 
 * Used for stores with flat arrays that have projectId fields (media, characters, scenes).
 * 
 * @param storeName - Base name for the storage files
 * @param splitFn - Function to split state into project and shared parts
 * @param mergeFn - Function to merge project and shared parts back together
 * @param sharingKey - Optional key in resourceSharing settings to check (e.g., 'shareCharacters')
 */
export function createSplitStorage<T = unknown>(
  storeName: string,
  splitFn: SplitFn<T>,
  mergeFn: MergeFn<T>,
  sharingKey?: 'shareCharacters' | 'shareScenes' | 'shareMedia',
): StateStorage {
  return {
    getItem: async (name: string): Promise<string | null> => {
      // 等待 project-store 完成 rehydration
      if (!useProjectStore.persist.hasHydrated()) {
        await new Promise<void>((resolve) => {
          const unsub = useProjectStore.persist.onFinishHydration(() => {
            unsub();
            resolve();
          });
        });
      }

      const pid = getActiveProjectId();
      
      if (!pid) {
        console.warn(`[SplitStorage] No activeProjectId, skip loading ${storeName} (${name})`);
        return null;
      }

      const projectKey = `_p/${pid}/${storeName}`;
      const sharedKey = `_shared/${storeName}`;

      // Check if cross-project sharing is enabled
      let sharingEnabled = false;
      if (sharingKey) {
        const sharing = getResourceSharing();
        sharingEnabled = sharing[sharingKey];
      }

      // Try to read current project's data
      const projectRaw = await fileStorage.getItem(projectKey);
      const allPids = getAllProjectIds();
      const otherPayloads: T[] = [];
      let sharedPayload: T | null = null;
      let mergedVersion = 0;

      // Load data from other projects and shared storage only when sharing is enabled,
      // or when checking whether split-storage has already been migrated.
      const loadSplitSources = async () => {
        if (sharingEnabled) {
          for (const otherPid of allPids) {
            if (otherPid === pid) continue;
            const otherKey = `_p/${otherPid}/${storeName}`;
            try {
              const otherRaw = await fileStorage.getItem(otherKey);
              if (!otherRaw) continue;
              const otherParsed = JSON.parse(otherRaw);
              const otherState = otherParsed?.state ?? otherParsed;
              otherPayloads.push(otherState);
              if (typeof otherParsed?.version === 'number') {
                mergedVersion = Math.max(mergedVersion, otherParsed.version);
              }
            } catch {
              // Skip corrupted project files
            }
          }
        } else {
          for (const otherPid of allPids) {
            if (otherPid === pid) continue;
            const otherKey = `_p/${otherPid}/${storeName}`;
            const exists = await fileStorage.getItem(otherKey);
            if (exists) return true;
          }
        }

        try {
          const sharedRaw = await fileStorage.getItem(sharedKey);
          if (sharedRaw) {
            const sharedParsed = JSON.parse(sharedRaw);
            sharedPayload = sharedParsed?.state ?? sharedParsed;
            if (typeof sharedParsed?.version === 'number') {
              mergedVersion = Math.max(mergedVersion, sharedParsed.version);
            }
            return true;
          }
        } catch {
          // Ignore malformed shared data; caller will fall back safely.
        }

        return sharingEnabled ? (otherPayloads.length > 0) : false;
      };

      try {
        if (projectRaw) {
          const projectState = JSON.parse(projectRaw);
          const projectPayload = projectState?.state ?? projectState;
          if (typeof projectState?.version === 'number') {
            mergedVersion = Math.max(mergedVersion, projectState.version);
          }

          if (sharingEnabled) {
            await loadSplitSources();
            // Merge: shared → other projects → current project (last gets priority for currentFolderId etc.)
            let merged: T = mergeFn(null, sharedPayload);
            for (const pd of otherPayloads) {
              merged = mergeFn(pd, merged);
            }
            merged = mergeFn(projectPayload, merged);

            console.log(`[SplitStorage] Loaded ${storeName}: ${allPids.length} projects merged (sharing ON)`);
            return JSON.stringify({
              state: merged,
              version: mergedVersion,
            });
          }

          // Cross-project sharing OFF: only current project's data
          console.log(`[SplitStorage] Loaded ${storeName}: project-only for ${pid.substring(0, 8)} (sharing OFF)`);
          return JSON.stringify({
            state: projectPayload,
            version: mergedVersion,
          });
        }

        // No current project file:
        // - If split storage already exists, treat as empty project data.
        // - If split storage does not exist, also start from empty state (no legacy fallback).
        const hasSplitData = await loadSplitSources();
        if (hasSplitData) {
          if (sharingEnabled) {
            let merged: T = mergeFn(null, sharedPayload);
            for (const pd of otherPayloads) {
              merged = mergeFn(pd, merged);
            }
            console.log(`[SplitStorage] Loaded ${storeName}: no project file for ${pid.substring(0, 8)}, merged shared/cross-project data`);
            return JSON.stringify({
              state: merged,
              version: mergedVersion,
            });
          }

          console.log(`[SplitStorage] Loaded ${storeName}: no project file for ${pid.substring(0, 8)}, returning empty project data`);
          return JSON.stringify({
            state: mergeFn(null, null),
            version: mergedVersion,
          });
        }

        console.log(`[SplitStorage] Split files not found for ${storeName}, returning empty state`);
        return JSON.stringify({
          state: mergeFn(null, null),
          version: 0,
        });
      } catch (error) {
        console.error(`[SplitStorage] Failed to parse/merge ${storeName}:`, error);
        if (projectRaw) return projectRaw;
        return JSON.stringify({
          state: mergeFn(null, null),
          version: 0,
        });
      }
    },

    setItem: async (name: string, value: string): Promise<void> => {
      const pid = getActiveProjectId();
      
      if (!pid) {
        await fileStorage.setItem(name, value);
        return;
      }

      try {
        const parsed = JSON.parse(value);
        const state = parsed.state ?? parsed;
        
        const { projectData, sharedData } = splitFn(state as T, pid);

        const projectKey = `_p/${pid}/${storeName}`;
        const sharedKey = `_shared/${storeName}`;

        // Save project-specific data
        const projectPayload = JSON.stringify({ state: projectData, version: parsed.version ?? 0 });
        await fileStorage.setItem(projectKey, projectPayload);
        
        // Save shared data
        const sharedPayload = JSON.stringify({ state: sharedData, version: parsed.version ?? 0 });
        await fileStorage.setItem(sharedKey, sharedPayload);
        
        console.log(`[SplitStorage] Saved ${storeName} split: project(${Math.round(projectPayload.length / 1024)}KB) + shared(${Math.round(sharedPayload.length / 1024)}KB)`);
      } catch (error) {
        console.error(`[SplitStorage] Failed to split ${storeName}, saving to legacy:`, error);
        await fileStorage.setItem(name, value);
      }
    },

    removeItem: async (name: string): Promise<void> => {
      const pid = getActiveProjectId();
      if (!pid) {
        await fileStorage.removeItem(name);
        return;
      }
      const projectKey = `_p/${pid}/${storeName}`;
      await fileStorage.removeItem(projectKey);
      // Note: shared data is NOT removed when a single project's data is removed
    },
  };
}
